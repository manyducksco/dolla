# Dolla's i18n (aka making your app speak other languages)

Aight, so your app is probably in English by default. But what if you wanna go global? That's where internationalization (or "i18n" if you're lazy) comes in. It's the whole process of making your app work in different languages.

You _could_ just use a giant object and some `if` statements, but that's a one-way ticket to spaghetti code city. It's a whole vibe killer.

That's why Dolla comes with its own i18n system right out of the box.

**Why it's lowkey the GOAT:**

- **It's Reactive AF:** The main `t()` function you use to get text returns a **signal**. That means if the user switches languages, your entire UI just updates. Automatically. No cap, it's kinda magic.
- **Smart String Templates:** You can put variables, format numbers, handle plurals, and all that jazz right in your translation strings. It's super powerful.
- **Load Translations How You Want:** You can hardcode them, load them from a JSON file, or even fetch them from an API. You do you.
- **Batteries Included:** It comes with formatters for numbers, dates, and lists, all using the browser's smart `Intl` stuff so it's always correct for whatever language you're in.

## Setting It Up

First things first, you gotta tell Dolla about the languages you support. You do this once when your app starts up, using `i18n.setup()`. It's super important to do this _before_ you mount your app so all the text is ready to go.

```jsx
import { createApp } from "@manyducks.co/dolla";
import { i18n } from "@manyducks.co/dolla/i18n";
import { App } from "./App.jsx";

const app = createApp(App);

// Set up all your languages
i18n
  .setup({
    // Tell it what language to start with. 'auto' is smart and will try to match the user's browser language.
    locale: "auto",
    translations: [
      // You can define strings right here...
      {
        locale: "en",
        strings: {
          greeting: "Hello, world!",
          nav: {
            home: "Home",
            about: "About Us",
          },
        },
      },
      // ...or tell it to fetch a JSON file for another language.
      {
        locale: "es",
        path: "/translations/es.json",
      },
      // ...or even give it a function that fetches them from an API!
      {
        locale: "ja",
        fetch: () => fetch("/api/translations/ja").then((res) => res.json()),
      },
    ],
  })
  .then(() => {
    // Only mount the app AFTER the translations are loaded!
    app.mount(document.body);
  });
```

## The `t()` function: Your New Bestie

This is the main function you'll be using. You import `t` and call it with a key to get the translated string.

```jsx
import { t } from "@manyducks.co/dolla/i18n";

function Greeting() {
  // This returns a signal, so it will automatically update if the language changes!
  return <h1>{t("greeting")}</h1>;
}

function Navbar() {
  return (
    <nav>
      <a href="/">{t("nav.home")}</a>
      <a href="/about">{t("nav.about")}</a>
    </nav>
  );
}
```

If a translation is missing, it won't crash your app. It'll just show something like `[MISSING: your.key]`, so you know you forgot something.

## Smart Strings: Variables and Formatting

This is where the magic happens. You can put placeholders in your strings and pass values to the `t()` function.

### Basic Variables

Just wrap your variable name in double curly braces: `{{variableName}}`. The best part? You can pass signals as values, and the text will update automatically when the signal changes\!

```jsx
// In your translation file:
{
  "welcome_message": "Welcome back, {{username}}!"
}

// In your component:
const [$username, setUsername] = useSignal("Alice");

// Because you're passing a signal, this will be reactive!
const $welcomeText = t("welcome_message", { username: $username });

// $welcomeText() is "Welcome back, Alice!"
// If you call setUsername("Bob"), $welcomeText() automatically becomes "Welcome back, Bob!"
```

### Formatting Numbers, Dates, and More\!

You can add formatters to your variables using a pipe `|`. Dolla comes with a few built-in ones.

- **`number`**: For formatting numbers (prices, percentages, etc.).
- **`datetime`**: For formatting dates and times.
- **`list`**: For formatting a list of things with commas and "and".

These formatters take options that are the same as the browser's `Intl` APIs, so they're super powerful. And yes, they're fully reactive with signals too.

```jsx
// In your translation file:
{
  "product_price": "Price: {{price | number(style: currency, currency: USD)}}"
}

// In your component:
const [$price, setPrice] = useSignal(49.99);

// This text will update automatically if you call setPrice() later!
const $priceText = t("product_price", { price: $price });
```

### Custom Formatters

You can even make your own formatters with `i18n.addFormat()`.

```js
// Set this up once when your app starts
i18n.addFormat("uppercase", (locale, value) => {
  return String(value).toUpperCase();
});

// In your translation file:
{ "shout": "HEY, {{name | uppercase}}!" }

// In your component:
t("shout", { name: "Bob" }); // Renders: "HEY, BOB!"
```

## Plurals and Context: Next-Level i18n

Languages are weird, especially with plurals. Dolla's i18n system has your back.

### Pluralization (`count`)

You can create different versions of a string based on a `count` you pass in. Dolla uses the standard pluralization rules for whatever language you're in (`one`, `other`, `few`, `many`, etc.). And you guessed itâ€”if you pass a signal for the count, the string will automatically switch between singular and plural\!

Just add `_one`, `_other`, etc., to your keys.

```jsx
// In your translation file:
{
  "message_count_one": "You have 1 new message.",
  "message_count_other": "You have {{count}} new messages."
}

// In your component:
const [$messageCount, setMessageCount] = useSignal(1);

// This will automatically switch between the singular and plural versions!
const $messageText = t("message_count", { count: $messageCount });

// $messageText() is "You have 1 new message."
// after setMessageCount(5), $messageText() becomes "You have 5 new messages."
```

### Context (`context`)

Sometimes you need a different translation for the same word based on the situation. For example, a "profile" button might be different for a user vs. a company.

```js
// In your translation file:
{
  "edit_profile": "Edit Profile",
  "edit_profile_company": "Edit Company Profile"
}

// In your component:
const userType = "company";
t("edit_profile", { context: userType }); // Renders: "Edit Company Profile"
t("edit_profile");                        // Renders: "Edit Profile"
```

## Using Formatters Directly

Sometimes you just wanna format a number or a date without a full translation string. The `i18n` object has helper functions for that too, and they're also reactive\!

```jsx
import { i18n } from "@manyducks.co/dolla/i18n";

function ProductDetails({ product }) {
  const $price = i18n.number(() => product().price, { style: "currency", currency: "USD" });
  const $lastUpdated = i18n.dateTime(() => product().updatedAt, { dateStyle: "long" });

  return (
    <div>
      <p>Price: {$price}</p>
      <p>Last Updated: {$lastUpdated}</p>
    </div>
  );
}
```

---

End.

- [ğŸ—‚ï¸ Docs](./index.md)
- [ğŸ  README](../README.md)
- [ğŸ¦† That's a lot of ducks.](https://www.manyducks.co)
